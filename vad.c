/* 
 * File:   vad.c
 * Author: arm-asus
 *
 * Created on 22 de septiembre de 2013, 01:09 PM
 */
/* Device header file */
#if defined(__XC16__)
    #include <xc.h>
#elif defined(__C30__)
    #if defined(__dsPIC33E__)
    	#include <p33Exxxx.h>
    #elif defined(__dsPIC33F__)
    	#include <p33Fxxxx.h>
    #endif
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <dsp.h>

#include "user.h"
#include "serialDriver.h"

#define CALIBRATION_START 100
#define CALIBRATION_END   1000
/*
 * 
 */

long counter[ADC_CHANNELS]={0,0,0,0};
float filteredSignal[BLOCKSIZE];

unsigned int CHANNELA0_OFFSET = 0;
unsigned int CHANNELA1_OFFSET = 0;
unsigned int CHANNELA2_OFFSET = 0;
unsigned int CHANNELA3_OFFSET = 0;

float EnergyCh0[CHANNEL_ENERGY_ARRAY] = {0,0,0,0,0,0,0,0,0,0};
float EnergyCh1[CHANNEL_ENERGY_ARRAY] = {0,0,0,0,0,0,0,0,0,0};
float EnergyCh2[CHANNEL_ENERGY_ARRAY] = {0,0,0,0,0,0,0,0,0,0};
float EnergyCh3[CHANNEL_ENERGY_ARRAY] = {0,0,0,0,0,0,0,0,0,0};
unsigned int array_counter = 0;

////////////////////////////////////////
// FIR Coeffecient Buffer
/*
 *%%
%fir1 Generated by Matlab
% n=order
% cuttof frequencies = [W1 W2], where Wn goes from 0 to 1
%        relative to the nyquist frequency
%        Nyq Freq= Freq/2;
%        Our used Freq is 1/(Samples per second)

n=20;
Freq=1/100E-6; % Freq for sampling at 100us
NyFreq=Freq/2;
W1= 200/NyFreq;   % Cuttoff 1 at 200Hz
W2= 1000/NyFreq;   % Cuttoff 2 at 1000Hz
COfreqs = [W1 W2];
 */
#define N 5   // Filter order

float coeffecients[N+1] = {
1.47932415385407e-18, 0.0952224452470798, 0.404777554752920, 0.404777554752920,
0.0952224452470798, 1.47932415385407e-18
};


float ProcessADCSamples(unsigned int *bufA, int offset, int channel){

    float energy_sum = 0;
    float zero_crossing = 0;
    float prev_val;

    energy_sum = 0;
    zero_crossing = 0;

    /* Remove the signal offset */
    int i=0;
    for( ; i<BLOCKSIZE; i++){
        float b=(float)*(bufA+i)-offset;
        filteredSignal[0]=b;
        energy_sum += (b*b);
        if( i > 0){
            if( b > 0 && prev_val < 0  ){
                zero_crossing++;
            }else if( b < 0 && prev_val > 0  ){
                zero_crossing++;
            }
        }
        prev_val = b;
    }

    /* Detect if voice is available */
    if(energy_sum > ENERGY_THRESHOLD){
        if(channel == 0){

        }else if (channel == 1){

        }else if (channel == 2){

        }else{

        }
    }else{
        if(channel == 0){

        }else if (channel == 1){

        }else if (channel == 2){

        }else{

        }
    }

    return energy_sum;

}

void CalculateAverage(unsigned int *bufA, int channel){

    int i=0;
    float a = 0;

    for( ; i < BLOCKSIZE; i++){
        a = a + (float)*(bufA+i);
    }
    a = a / BLOCKSIZE;

    if(channel == 0 ){
        CHANNELA0_OFFSET = (CHANNELA0_OFFSET + a) / 2;
    }else if(channel == 1){
        CHANNELA1_OFFSET = (CHANNELA1_OFFSET + a) / 2;
    }else if(channel == 2){
        CHANNELA2_OFFSET = (CHANNELA2_OFFSET + a) / 2;
    }else{
        CHANNELA3_OFFSET = (CHANNELA3_OFFSET + a) / 2;
    }

}

void adcService(void)
{
    static unsigned int DmaBuffer = 0;
    static unsigned int initCounter = 0;
    static unsigned int StartFlag = 0;
    PORTBbits.RB15 ^= 1;

    if(StartFlag == 1)
    {
        if (DmaBuffer == 1)
        {

            // Register B has just been written so it can be processed
            EnergyCh0[array_counter] = ProcessADCSamples(&BufferB_regs.channel[0][0], CHANNELA0_OFFSET, 0);
            EnergyCh1[array_counter] = ProcessADCSamples(&BufferB_regs.channel[1][0], CHANNELA1_OFFSET, 1);
            EnergyCh2[array_counter] = ProcessADCSamples(&BufferB_regs.channel[2][0], CHANNELA2_OFFSET, 2);
            EnergyCh3[array_counter] = ProcessADCSamples(&BufferB_regs.channel[3][0], CHANNELA3_OFFSET, 3);

        }
        else
        {

            EnergyCh0[array_counter] = ProcessADCSamples(&BufferA_regs.channel[0][0], CHANNELA0_OFFSET, 0);
            EnergyCh1[array_counter] = ProcessADCSamples(&BufferA_regs.channel[1][0], CHANNELA1_OFFSET, 1);
            EnergyCh2[array_counter] = ProcessADCSamples(&BufferA_regs.channel[2][0], CHANNELA2_OFFSET, 2);
            EnergyCh3[array_counter] = ProcessADCSamples(&BufferA_regs.channel[3][0], CHANNELA3_OFFSET, 3);

        }
    }
    else
    {

        if (initCounter > CALIBRATION_START && initCounter <= CALIBRATION_END)
        {
            if (DmaBuffer == 1)
            {
                CalculateAverage(&BufferB_regs.channel[0][0], 0);
                CalculateAverage(&BufferB_regs.channel[1][0], 1);
                CalculateAverage(&BufferB_regs.channel[2][0], 2);
                CalculateAverage(&BufferB_regs.channel[3][0], 3);
            }
            else
            {
                CalculateAverage(&BufferA_regs.channel[0][0], 0);
                CalculateAverage(&BufferA_regs.channel[1][0], 1);
                CalculateAverage(&BufferA_regs.channel[2][0], 2);
                CalculateAverage(&BufferA_regs.channel[3][0], 3);
            }
            writeString(".");
            initCounter++;
        }
        else if (initCounter > CALIBRATION_END)
        {
            StartFlag=1;
            writeString("\n\rCalibration ended\n\r");
        }else
        {
            initCounter++;
            if (initCounter == CALIBRATION_START )
            {
                writeString("Calibration started");
            }
        }
        
    }
    DmaBuffer ^= 1;

}